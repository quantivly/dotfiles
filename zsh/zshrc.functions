#==============================================================================
# Shell Utility Functions
#==============================================================================
# Provides 13 utility functions organized by category.
# All functions include inline "Usage: ..." documentation.
#
# File/Directory Management:
#   - pathadd: Safely add directories to PATH (prevents duplicates)
#   - mkcd: Create directory and cd into it
#   - backup: Create timestamped backup of file
#   - extract: Universal archive extractor (handles tar, zip, gz, etc.)
#   - dirsize: Show directory sizes sorted by size
#   - mkdate: Create dated directory with optional prefix
#
# Navigation:
#   - fcd: Fuzzy directory search and cd (requires fzf)
#
# Network:
#   - myip: Get public IP address
#   - localip: Get local IP address
#
# Development:
#   - gwtc: Git worktree create helper (create worktree in ../worktrees/<branch>)
#   - note: Quick note taking with timestamps
#   - psgrep: Search for processes by pattern
#   - killnamed: Kill process by name (with confirmation)
#
# See also: examples/git-workflows.md, examples/docker-workflows.md
#==============================================================================

# Add directories to PATH if not already present
pathadd() {
  # Usage: pathadd <directory1> [directory2 ...]
  # Adds one or more directories to PATH only if they exist and aren't already in PATH
  for dir in "$@"; do
    if [ -d "$dir" ]; then
      if [[ ":$PATH:" != *":$dir:"* ]]; then
        PATH="${PATH:+"$PATH:"}$dir"
      fi
    fi
  done
}

# Create directory and cd into it
mkcd() {
  # Usage: mkcd <directory>
  # Creates a directory (including parents) and changes into it
  if [ $# -ne 1 ]; then
    echo "Usage: mkcd <directory>"
    return 1
  fi
  mkdir -p "$1" && cd "$1"
}

# Find and cd to a directory using fzf
fcd() {
  # Usage: fcd [starting_directory]
  # Fuzzy find directories and cd into selection
  local dir
  local start_dir="${1:-.}"

  # Use fd if available (much faster), otherwise fall back to find
  if command -v fd &> /dev/null; then
    dir=$(fd --type d --hidden --follow \
      --exclude .git --exclude node_modules --exclude .cache \
      --exclude .venv --exclude venv \
      --exclude build --exclude dist --exclude target \
      --exclude .npm --exclude .cargo --exclude .gradle \
      . "$start_dir" | fzf +m --preview 'ls -la {}' --preview-window=right:50%:wrap)
  elif command -v fdfind &> /dev/null; then
    # Ubuntu installs it as fdfind
    dir=$(fdfind --type d --hidden --follow \
      --exclude .git --exclude node_modules --exclude .cache \
      --exclude .venv --exclude venv \
      --exclude build --exclude dist --exclude target \
      --exclude .npm --exclude .cargo --exclude .gradle \
      . "$start_dir" | fzf +m --preview 'ls -la {}' --preview-window=right:50%:wrap)
  else
    # Fallback to find with exclusions
    dir=$(find "$start_dir" -type d \( \
      -name .git -o -name node_modules -o -name .cache \
      -o -name .venv -o -name venv \
      -o -name build -o -name dist -o -name target \
      -o -name .npm -o -name .cargo -o -name .gradle \
      \) -prune -o -type d -print 2>/dev/null | fzf +m --preview 'ls -la {}' --preview-window=right:50%:wrap)
  fi

  [ -n "$dir" ] && cd "$dir"
}

# Quick backup of a file
backup() {
  # Usage: backup <file>
  # Creates a timestamped backup copy of a file
  if [ $# -ne 1 ]; then
    echo "Usage: backup <file>"
    return 1
  fi
  local timestamp=$(date +%Y%m%d_%H%M%S)
  cp "$1" "${1}.backup_${timestamp}"
  echo "Created backup: ${1}.backup_${timestamp}"
}

# Extract archives of any type
extract() {
  # Usage: extract <file>
  # Note: oh-my-zsh extract plugin also provides this, but this is a fallback
  if [ $# -ne 1 ]; then
    echo "Usage: extract <file>"
    return 1
  fi
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Get public IP address
myip() {
  # Usage: myip
  # Displays your public IP address
  curl -s https://api.ipify.org && echo
}

# Get local IP address
localip() {
  # Usage: localip
  # Displays your local IP address
  hostname -I | awk '{print $1}'
}

# Quick note taking
note() {
  # Usage: note <message>
  # Appends a timestamped note to ~/notes.txt
  local notes_file="${HOME}/notes.txt"
  if [ $# -eq 0 ]; then
    # Display notes if no arguments
    if [ -f "$notes_file" ]; then
      cat "$notes_file"
    else
      echo "No notes found. Use: note <message> to create one."
    fi
  else
    # Add note with timestamp
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$notes_file"
    echo "Note added to $notes_file"
  fi
}

# Search for a running process
psgrep() {
  # Usage: psgrep <pattern>
  # Greps for a process by name
  ps aux | grep -v grep | grep -i -e VSZ -e "$@"
}

# Kill process by name
killnamed() {
  # Usage: killnamed <process_name>
  # Kills all processes matching the given name
  if [ $# -ne 1 ]; then
    echo "Usage: killnamed <process_name>"
    return 1
  fi
  ps aux | grep -v grep | grep "$1" | awk '{print $2}' | xargs kill
}

# Create a dated directory
mkdate() {
  # Usage: mkdate [prefix]
  # Creates a directory with current date (YYYY-MM-DD format)
  local date_str=$(date +%Y-%m-%d)
  local dir_name="${1:+${1}_}${date_str}"
  mkdir -p "$dir_name" && cd "$dir_name"
}

# Show directory sizes
dirsize() {
  # Usage: dirsize [directory]
  # Shows sizes of directories in human-readable format
  du -sh "${1:-.}"/* 2>/dev/null | sort -h
}

# Git worktree wrapper - creates worktree in ../worktrees/<branch>
# Note: 'gwt' is already defined by oh-my-zsh git plugin as 'git worktree'
# So we use 'gwtc' (git worktree create) for this helper function
gwtc() {
  # Usage: gwtc <branch_name>
  # Creates a git worktree in ../worktrees/<branch_name> and cd into it
  if [ $# -ne 1 ]; then
    echo "Usage: gwtc <branch_name>"
    echo "Creates a git worktree in ../worktrees/<branch_name>"
    return 1
  fi
  local worktree_dir="../worktrees/$1"
  git worktree add "$worktree_dir" "$1" && cd "$worktree_dir"
}
