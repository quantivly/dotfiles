#==============================================================================
# Shell Utility Functions
#==============================================================================
# Provides 17 utility functions organized by category.
# All functions include inline "Usage: ..." documentation.
#
# File/Directory Management:
#   - pathadd: Safely add directories to PATH (prevents duplicates)
#   - mkcd: Create directory and cd into it
#   - backup: Create timestamped backup of file
#   - extract: Universal archive extractor (handles tar, zip, gz, etc.)
#   - dirsize: Show directory sizes sorted by size
#   - mkdate: Create dated directory with optional prefix
#
# Navigation:
#   - fcd: Fuzzy directory search and cd with enhanced preview (requires fzf)
#
# Network:
#   - myip: Get public IP address
#   - localip: Get local IP address
#
# Development:
#   - gwtc: Git worktree create helper (create worktree in ../worktrees/<branch>)
#   - note: Quick note taking with timestamps
#   - psgrep: Search for processes by pattern
#   - killnamed: Kill process by name (with confirmation)
#
# Performance & Diagnostics:
#   - zsh_bench: Benchmark zsh startup time with iterations
#   - zsh_profile: Profile zsh startup with detailed timing breakdown
#   - tool_status: Show modern CLI tool installation status
#
# See also: examples/git-workflows.md, examples/docker-workflows.md, examples/fzf-recipes.md
#==============================================================================

# Add directories to PATH if not already present
pathadd() {
  # Usage: pathadd <directory1> [directory2 ...]
  # Adds one or more directories to PATH only if they exist and aren't already in PATH
  for dir in "$@"; do
    if [ -d "$dir" ]; then
      if [[ ":$PATH:" != *":$dir:"* ]]; then
        PATH="${PATH:+"$PATH:"}$dir"
      fi
    fi
  done
}

# Create directory and cd into it
mkcd() {
  # Usage: mkcd <directory>
  # Creates a directory (including parents) and changes into it
  if [ $# -ne 1 ]; then
    echo "Usage: mkcd <directory>"
    return 1
  fi
  mkdir -p "$1" && cd "$1"
}

# Find and cd to a directory using fzf
fcd() {
  # Usage: fcd [starting_directory]
  # Fuzzy find directories and cd into selection with enhanced preview
  local dir
  local start_dir="${1:-.}"

  # Enhanced preview showing directory contents and git status if applicable
  local preview_cmd='ls -la {} 2>/dev/null; echo ""; if [ -d {}/.git ]; then echo "Git repo:"; git -C {} status --short 2>/dev/null || echo "Git status unavailable"; fi'

  # Use fd if available (much faster), otherwise fall back to find
  if command -v fd &> /dev/null; then
    dir=$(fd --type d --hidden --follow \
      --exclude .git --exclude node_modules --exclude .cache \
      --exclude .venv --exclude venv \
      --exclude build --exclude dist --exclude target \
      --exclude .npm --exclude .cargo --exclude .gradle \
      . "$start_dir" | fzf +m \
      --header "Navigate to directory (showing from: $start_dir)" \
      --preview "$preview_cmd" \
      --preview-window=right:50%:wrap)
  elif command -v fdfind &> /dev/null; then
    # Ubuntu installs it as fdfind
    dir=$(fdfind --type d --hidden --follow \
      --exclude .git --exclude node_modules --exclude .cache \
      --exclude .venv --exclude venv \
      --exclude build --exclude dist --exclude target \
      --exclude .npm --exclude .cargo --exclude .gradle \
      . "$start_dir" | fzf +m \
      --header "Navigate to directory (showing from: $start_dir)" \
      --preview "$preview_cmd" \
      --preview-window=right:50%:wrap)
  else
    # Fallback to find with exclusions
    dir=$(find "$start_dir" -type d \( \
      -name .git -o -name node_modules -o -name .cache \
      -o -name .venv -o -name venv \
      -o -name build -o -name dist -o -name target \
      -o -name .npm -o -name .cargo -o -name .gradle \
      \) -prune -o -type d -print 2>/dev/null | fzf +m \
      --header "Navigate to directory (showing from: $start_dir)" \
      --preview "$preview_cmd" \
      --preview-window=right:50%:wrap)
  fi

  if [ -n "$dir" ]; then
    cd "$dir" && echo "Changed to: $(pwd)"
  fi
}

# Quick backup of a file
backup() {
  # Usage: backup <file>
  # Creates a timestamped backup copy of a file
  if [ $# -ne 1 ]; then
    echo "Usage: backup <file>"
    return 1
  fi
  local timestamp=$(date +%Y%m%d_%H%M%S)
  cp "$1" "${1}.backup_${timestamp}"
  echo "Created backup: ${1}.backup_${timestamp}"
}

# Extract archives of any type
extract() {
  # Usage: extract <file>
  # Note: oh-my-zsh extract plugin also provides this, but this is a fallback
  if [ $# -ne 1 ]; then
    echo "Usage: extract <file>"
    return 1
  fi
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Get public IP address
myip() {
  # Usage: myip
  # Displays your public IP address
  curl -s https://api.ipify.org && echo
}

# Get local IP address
localip() {
  # Usage: localip
  # Displays your local IP address
  hostname -I | awk '{print $1}'
}

# Quick note taking
note() {
  # Usage: note <message>
  # Appends a timestamped note to ~/notes.txt
  local notes_file="${HOME}/notes.txt"
  if [ $# -eq 0 ]; then
    # Display notes if no arguments
    if [ -f "$notes_file" ]; then
      cat "$notes_file"
    else
      echo "No notes found. Use: note <message> to create one."
    fi
  else
    # Add note with timestamp
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$notes_file"
    echo "Note added to $notes_file"
  fi
}

# Search for a running process
psgrep() {
  # Usage: psgrep <pattern>
  # Greps for a process by name
  ps aux | grep -v grep | grep -i -e VSZ -e "$@"
}

# Kill process by name
killnamed() {
  # Usage: killnamed <process_name>
  # Kills all processes matching the given name
  if [ $# -ne 1 ]; then
    echo "Usage: killnamed <process_name>"
    return 1
  fi
  ps aux | grep -v grep | grep "$1" | awk '{print $2}' | xargs kill
}

# Create a dated directory
mkdate() {
  # Usage: mkdate [prefix]
  # Creates a directory with current date (YYYY-MM-DD format)
  local date_str=$(date +%Y-%m-%d)
  local dir_name="${1:+${1}_}${date_str}"
  mkdir -p "$dir_name" && cd "$dir_name"
}

# Show directory sizes
dirsize() {
  # Usage: dirsize [directory]
  # Shows sizes of directories in human-readable format
  du -sh "${1:-.}"/* 2>/dev/null | sort -h
}

# Git worktree wrapper - creates worktree in ../worktrees/<branch>
# Note: 'gwt' is already defined by oh-my-zsh git plugin as 'git worktree'
# So we use 'gwtc' (git worktree create) for this helper function
gwtc() {
  # Usage: gwtc <branch_name>
  # Creates a git worktree in ../worktrees/<branch_name> and cd into it
  if [ $# -ne 1 ]; then
    echo "Usage: gwtc <branch_name>"
    echo "Creates a git worktree in ../worktrees/<branch_name>"
    return 1
  fi
  local worktree_dir="../worktrees/$1"
  git worktree add "$worktree_dir" "$1" && cd "$worktree_dir"
}

# Performance monitoring for zsh startup
zsh_bench() {
  # Usage: zsh_bench [iterations]
  # Benchmarks zsh startup time with detailed breakdown
  local iterations="${1:-5}"
  echo "Benchmarking zsh startup time ($iterations iterations)..."
  
  for i in $(seq 1 $iterations); do
    echo "Run $i:"
    /usr/bin/time -f "  Real: %e seconds, User: %U, Sys: %S" zsh -i -c exit
  done
  
  echo ""
  echo "To profile what's slow, run: zsh_profile"
}

# Profile zsh startup with detailed timing
zsh_profile() {
  # Usage: zsh_profile
  # Shows detailed timing of zsh startup components
  echo "Profiling zsh startup with detailed timing..."
  echo "This will show which parts of .zshrc are slowest:"
  echo ""
  
  PS4='+ %D{%s.%.} %N:%i> ' zsh -i -x -c exit 2>&1 | \
    awk '/\+.*source.*zshrc/ { start = $2; next } 
         /\+.*\[/ { if (start) { print $2 - start " seconds: " $0; start = 0 } }' | \
    sort -n | tail -10
  
  echo ""
  echo "For a simpler benchmark, run: zsh_bench"
}

# Show tool installation status
tool_status() {
  # Usage: tool_status
  # Shows which modern CLI tools are installed and available
  echo "=== Modern CLI Tools Status ==="
  
  local tools=(
    "fd:fdfind:Better find"
    "bat:batcat:Syntax highlighting cat" 
    "eza:exa:Better ls with icons"
    "rg::Better grep (ripgrep)"
    "delta::Better git diff"
    "htop::Better top"
    "fzf::Fuzzy finder"
    "gh::GitHub CLI"
    "direnv::Per-directory env vars"
  )
  
  for tool_info in "${tools[@]}"; do
    IFS=':' read -r primary alternative description <<< "$tool_info"
    
    if command -v "$primary" &> /dev/null; then
      echo "✓ $primary - $description"
    elif [[ -n "$alternative" ]] && command -v "$alternative" &> /dev/null; then
      echo "✓ $alternative - $description (as $alternative)"
    else
      echo "✗ $primary - $description (not installed)"
    fi
  done
  
  echo ""
  echo "Environment variables set:"
  [[ -n "$_HAS_FD" ]] && echo "  _HAS_FD=$_HAS_FD"
  [[ -n "$_HAS_BAT" ]] && echo "  _HAS_BAT=$_HAS_BAT"  
  [[ -n "$_HAS_MODERN_LS" ]] && echo "  _HAS_MODERN_LS=$_HAS_MODERN_LS"
  [[ -n "$_HAS_RG" ]] && echo "  _HAS_RG=$_HAS_RG"
}
